---
layout: post
title: Elm Plane - a Flappy Bird Clone in Elm
---

The really interesting topics are the ones that you don't understand at first. For me, Rx is such a topic. I understand enough to get by, but I'm not yet thinking in a functional reactive way. So, what better way to get into that state of mind than to try writing something in a language where there is no other choice but to write pure functional reactive code.
It's been a while since I learned a new language. Sure, I read the odd blog post about Go or Rust and I can definitely recommend the book ["Seven Languages in Seven Weeks"](https://pragprog.com/book/btlang/seven-languages-in-seven-weeks) for a glimpse into some interesting concepts, but it wasn't until I heard about Elm on the [JavaScript Jabber](https://devchat.tv/js-jabber/175-jsj-elm-with-evan-czaplicki-and-richard-feldman) podcast that I thought, this is exactly what I need! (I later heard about [PureScript](http://www.purescript.org/) in another Javascript Jabber [episode](https://devchat.tv/js-jabber/189-jsj-purescript-with-john-a-de-goes-and-phil-freeman) and it definitely sounds interesting as well.)

I wanted to [quickly pick]({% post_url 2015-11-28-the-idea-obstacle %}) a small project to start working on and settled on a flappy bird clone. There are a lot of blog posts about Elm which helped me get started, so I'm not gonna talk about basic Elm stuff here as I feel it is pretty much covered (Check the end of the post for links to a few of those posts). I am going to break down the code and describe some interesting bits in more depth.

### Model

### Update methods
state transitions
sampleOn delta vs. mergeMany and the discrete key down problem
Random

### View

### Modules
Pretty quickly it was clear that I need to split up the code into files/modules so it'll be easier to deal with. Most if not all of the examples on the Elm website are small and contained in one file, and from looking at the games there didn't seem to be a consensus about the best way to split up the code. Creating a module for each component in the game felt like a bit of an overkill since there are basically two - the plane and the columns.

I started by dividing the code between two files - a `Types.elm` file that would contain all the type definitions and a Main file that contained pretty much all of the logic. When `Main.elm` got too big I started a `Utils.elm` file, and soon after I realized this division is not very balanced or properly "domained" (that's not a real word, but it is the name of a [metal band](http://www.metal-archives.com/bands/Domained/12933)).

The biggest problems were:
- The `Main.elm` is still too big and contains pretty much everything.
- It's not clear what should go into the `Utils.elm` file and what should stay in `Main.elm`.

After some thinking I ended up with the obvious choice which looked pretty good:
- `Model.elm` contains the game's state and type definitions for it.
- `Update.elm` contains the update logic and basically generates a new state based on the old one (the [foldp](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#foldp) logic).
- `View.elm` defines how to construct a view based on a game state.
- `Main.elm` connects the dots.

This is the obvious choice because it is literally the logical modules of the application. Plus, it was pretty neat that the update code had nothing to do with the view code and vice versa (the view code didn't need to know anything related to the update logic).
### Links
