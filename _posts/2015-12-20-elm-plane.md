---
layout: post
title: Elm Plane - a Flappy Bird Clone in Elm
---

The really interesting topics are the ones that you don't understand at first. For me, Rx is such a topic. I understand enough to get by, but I'm not yet thinking in a functional reactive way. So, what better way to get into that state of mind than to try writing something in a language where there is no other choice but to write pure functional reactive code?

It's been a while since I learned a new language. Sure, I read the odd blog post about Go or Rust and I can definitely recommend the book ["Seven Languages in Seven Weeks"](https://pragprog.com/book/btlang/seven-languages-in-seven-weeks) for a glimpse into some interesting concepts, but it wasn't until I heard about Elm on the [JS Jabber](https://devchat.tv/js-jabber/175-jsj-elm-with-evan-czaplicki-and-richard-feldman) podcast that I thought, this is exactly what I need! (I later heard about [PureScript](http://www.purescript.org/) in another JS Jabber [episode](https://devchat.tv/js-jabber/189-jsj-purescript-with-john-a-de-goes-and-phil-freeman) and it definitely sounds interesting as well.)

I wanted to [quickly pick]({% post_url 2015-11-28-the-idea-obstacle %}) a small project to start working on and settled on a flappy bird clone. There are a lot of blog posts about Elm which helped me get started, so I'm not gonna talk about basic Elm stuff here as I feel it is pretty much covered (check the end of the post for links to a few of those posts). I am going to break down the code and describe some interesting bits in more depth.

The pattern for writing games in Elm (or applications for that matter) breaks down the code to four parts:

The ***Model*** holds the state of the game which will include positions, velocity, score and other stuff like that. This is kinda like the application state in [Flux/Redux](https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree). Like everything else in Elm this state record is immutable, which means that we're not gonna modify that record, we're gonna replace it with a new record every update.

The ***Input*** part defines the inputs for the game (keys, passage of time) and the [Signal](http://elm-lang.org/guide/reactivity) for those inputs.

The ***Update*** part defines what should be the next state of the game based on new inputs (just like a reducer). Here's a few examples:
- When space is pressed the spaceship should shoot
- When the up arrow key is pressed the character should jump.
- When a millisecond passes the plane's vertical velocity (gravity) increases.

The ***View*** part defines how to render a given game state. It is completely separate from the ***Update*** code.

<p align="center">
  <div style="width:50%;margin:auto;text-align:center;">
    <img class="gfyitem" data-id="BeneficialGoodnaturedAnchovy" data-expand=true/>
    Ok, so I'm not very good.
  </div>
</p>

## Model
The `Model.elm` file holds the default game state, the one which every game starts with. The file also contains all of the relevant type definitions and a constants record that holds all sorts of variables that the game uses that, well, stay constant - size of things, value of gravity and speed etc.

Here's what a game state for elm plane looks like:

```
type alias Game =
  { state : State                 --1
  , backgroundX : Float           --2
  , y : Float                     --3
  , vy : Float                    --4
  , timeToPillar : Float          --5
  , pillars : Array.Array Pillar  --6
  , score : Int                   --7
  }
```
1. The state in which the game is in. Can be one of three:
  - In the start screen, waiting for a user input to start a game
  - In an active game
  - In the game over screen, waiting for a user input to switch to the start screen
2. The horizontal position of the background, used for scrolling the background image.
3. The vertical position of the plane.
4. The vertical velocity of the plane.
5. The timespan left to the next column spawn
6. The columns that are currently in play.
7. The player's score.

## Input
<del>Flappy Bird</del> Elm Plane is a pretty simple game right? the only inputs are one key (space) and the passage of time. So on the first iteration I defined the input type to contain a Bool property and a Time property, where delta is an Float Signal generated by the [FPS ticker](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Time#fps) converted to seconds (delta between ticks).

```
delta =
      Signal.map inSeconds (fps 45)

type alias Input =                  
    { space : Bool
    , delta : Time
    }
```
I then defined the Input Signal to sample both on delta. This means that when there's a new value for the delta Signal, build a new record out of the current state of the of the space key (whether it is pressed) and the current state of the Time Signal (4).

```
input : Signal Input               
input =
        Signal.sampleOn delta <|      --3
          Signal.map2 Input           --4
          Keyboard.space
          delta
```          
<p align="center">
  <div style="width:50%;margin:auto;text-align:center;">
    <img class="gfyitem" data-id="RegalFrigidGreathornedowl" data-expand=true/>
    Goodbye, I'm needed elsewhere.
  </div>
</p>

## Update
This is probably the interesting part. In `Update.elm` there are a bunch of functions that return a new game state based on an input and the old game state.

First you define what an input record looks like you have to define how to  the input's Signal which
This is how I defined the inputs signal at first:
```
type alias Input =                  --1
    { space : Bool
    , delta : Time
    }

input : Signal Input                --2
input =
        Signal.sampleOn delta <|    --3
          Signal.map2 Input         --4
          Keyboard.space
          delta
```          
This means that an input is a record that has a `Bool` property called `space` and a `Time` property called `delta` (1).
scrolling the background
state transitions
sampleOn delta vs. mergeMany and the discrete key down problem
Random

### View

### Modules
Pretty quickly it was clear that I need to split up the code into files/modules so it'll be easier to deal with. Most if not all of the examples on the Elm website are small and contained in one file, and from looking at the games there didn't seem to be a consensus about the best way to split up the code. Creating a module for each component in the game felt like a bit of an overkill since there are basically two - the plane and the columns.

I started by dividing the code between two files - a `Types.elm` file that would contain all the type definitions and a Main file that contained pretty much all of the logic. When `Main.elm` got too big I started a `Utils.elm` file, and soon after I realized this division is not very balanced or properly "domained" (that's not a real word, but it is the name of a [metal band](http://www.metal-archives.com/bands/Domained/12933)).

The biggest problems were:
- The `Main.elm` is still too big and contains pretty much everything.
- It's not clear what should go into the `Utils.elm` file and what should stay in `Main.elm`.

After some thinking I ended up with the obvious choice which looked pretty good:
- `Model.elm` contains the game's state and type definitions for it.
- `Update.elm` contains the update logic and basically generates a new state based on the old one (the [foldp](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#foldp) logic).
- `View.elm` defines how to construct a view based on a game state.
- `Main.elm` connects the dots.

This is the obvious choice because it is literally the logical modules of the application. Plus, it was pretty neat that the update code had nothing to do with the view code and vice versa (the view code didn't need to know anything related to the update logic).
### Links
<script type"text/javascript" src="https://assets.gfycat.com/gfycat.js"></script>
